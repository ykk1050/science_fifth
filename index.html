<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì´ˆë“±í•™êµ 5í•™ë…„ ê³¼í•™ ì„œë°”ì´ë²Œ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Malgun Gothic', 'Apple SD Gothic Neo', sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #95a5a6;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        /* UI ë ˆì´ì–´ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        /* ê³µí†µ íŒì—… ìŠ¤íƒ€ì¼ */
        .popup {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            pointer-events: auto;
            border: 2px solid #3498db;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        h1 { margin: 0 0 20px 0; color: #3498db; text-shadow: 2px 2px 0 #000; font-size: 2rem; }
        h2 { color: #f1c40f; margin-bottom: 15px; }
        p { font-size: 1.1rem; line-height: 1.5; margin: 10px 0; }
        
        /* ì…ë ¥ í•„ë“œ */
        input[type="text"] {
            padding: 10px;
            font-size: 1.2rem;
            border-radius: 5px;
            border: none;
            width: 70%;
            text-align: center;
            margin-bottom: 15px;
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px 5px;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            font-family: inherit;
        }
        button:hover { transform: scale(1.05); background: #c0392b; }
        button:active { transform: scale(0.95); }
        button.secondary { background: #34495e; border: 1px solid #7f8c8d; }
        button.secondary:hover { background: #2c3e50; }
        button.green { background: #27ae60; }
        button.green:hover { background: #219150; }

        .hidden { display: none !important; }

        /* ê¸°ë¡ í…Œì´ë¸” */
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.9rem; }
        th, td { padding: 8px; border-bottom: 1px solid #555; }
        th { color: #3498db; }
        tr:nth-child(1) td { color: #f1c40f; font-weight: bold; } /* 1ë“± ê°•ì¡° */

        /* HUD (ê²Œì„ ì¤‘ ìƒë‹¨ í‘œì‹œ) */
        #hud {
            position: absolute;
            top: 90px; /* ìƒë‹¨ ë¬¸ì œ í‘œì‹œì¤„ ì•„ë˜ */
            right: 10px;
            text-align: right;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            font-size: 1.0rem;
        }
        .stat-item { margin-bottom: 5px; }
        .combo-text { color: #f1c40f; font-size: 1.2rem; transition: transform 0.1s; }
        .combo-active { transform: scale(1.2); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <div class="stat-item">ì ìˆ˜: <span id="hud-score">0</span></div>
        <div class="stat-item">ì •ë‹µ: <span id="hud-total">0</span></div>
        <div class="stat-item combo-text" id="hud-combo">Combo: 0</div>
    </div>

    <div id="ui-layer">
        <!-- ì‹œì‘ í™”ë©´ -->
        <div id="start-screen" class="popup">
            <h1>ğŸŒ¤ï¸ ê³¼í•™ ì„œë°”ì´ë²Œ</h1>
            <p>ì´ˆë“±í•™êµ 5í•™ë…„ ê³¼í•™ ì´ì •ë¦¬</p>
            
            <input type="text" id="nickname-input" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="8">
            
            <div id="resume-area" class="hidden">
                <p style="color: #f39c12;">ì €ì¥ëœ ê²Œì„ì´ ìˆìŠµë‹ˆë‹¤!</p>
                <button class="green" onclick="loadGameAndStart()">ì´ì–´í•˜ê¸°</button>
            </div>

            <div>
                <button onclick="startNewGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
                <button class="secondary" onclick="showRecords()">ê¸°ë¡ ë³´ê¸°</button>
            </div>
        </div>

        <!-- ê¸°ë¡ í™”ë©´ -->
        <div id="records-screen" class="popup hidden">
            <h2>ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</h2>
            <div style="max-height: 200px; overflow-y: auto;">
                <table id="records-table">
                    <thead>
                        <tr><th>ìˆœìœ„</th><th>ì´ë¦„</th><th>ì ìˆ˜</th><th>ì •ë‹µ</th></tr>
                    </thead>
                    <tbody><!-- JSë¡œ ì±„ì›€ --></tbody>
                </table>
            </div>
            <button class="secondary" onclick="hideRecords()">ë‹«ê¸°</button>
        </div>

        <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
        <div id="game-over-screen" class="popup hidden">
            <h1>ê²Œì„ ì˜¤ë²„</h1>
            <p id="final-msg">ìˆ˜ê³ í–ˆìŠµë‹ˆë‹¤!</p>
            <p id="final-score-text">ì ìˆ˜: 0</p>
            <p id="final-stats-text">ì´ ì •ë‹µ: 0 / ìµœëŒ€ ì½¤ë³´: 0</p>
            <button onclick="returnToMain()">ë©”ì¸ìœ¼ë¡œ</button>
        </div>
    </div>

<script>
/**
 * 1. ì„¤ì • ë° ë¦¬ì†ŒìŠ¤
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let GAME_WIDTH = window.innerWidth > 600 ? 600 : window.innerWidth;
let GAME_HEIGHT = window.innerHeight;
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

const playerImg = new Image();
playerImg.src = 'spaceship.png';
const enemyImg = new Image();
enemyImg.src = 'alien.png';

// ë¬¸ì œ ë°ì´í„° (ì „ì²´ í¬í•¨)
const QUESTIONS = [
    // [ë‚ ì”¨ì™€ ìš°ë¦¬ ìƒí™œ]
    { q: "ìŠµë„ëŠ” ë¬´ì—‡ì„ ì˜ë¯¸í•˜ë‚˜ìš”?", a: "ê³µê¸° ì¤‘ ìˆ˜ì¦ê¸°ì˜ ì–‘", w: ["ê³µê¸°ì˜ ì˜¨ë„", "ë°”ëŒì˜ ì„¸ê¸°"] },
    { q: "ì´ìŠ¬ì´ë‚˜ ì•ˆê°œëŠ” ìˆ˜ì¦ê¸°ê°€ ë¬´ì—‡ì´ ëœ ê²ƒì¸ê°€ìš”?", a: "ë¬¼ë°©ìš¸", w: ["ì–¼ìŒ", "ëˆˆ"] },
    { q: "ë°”ëŒì€ ê³µê¸°ê°€ ì–´ë””ë¡œ ì´ë™í•˜ëŠ” ê²ƒì¸ê°€ìš”?", a: "ê³ ê¸°ì•• â†’ ì €ê¸°ì••", w: ["ì €ê¸°ì•• â†’ ê³ ê¸°ì••", "ê³ ê¸°ì•• â†’ ê³ ê¸°ì••"] },
    { q: "ìš°ë¦¬ë‚˜ë¼ ì—¬ë¦„ì²  ë‚ ì”¨ì— ì˜í–¥ì„ ì£¼ëŠ” ê¸°ë‹¨ì€?", a: "ë¶íƒœí‰ì–‘ (ê³ ì˜¨ë‹¤ìŠµ)", w: ["ì‹œë² ë¦¬ì•„ (í•œë­ê±´ì¡°)", "ì˜¤í˜¸ì¸ í¬í•´ (í•œë­ë‹¤ìŠµ)"] },
    { q: "í•˜ë£¨ ì¤‘ ê¸°ì˜¨ì´ ê°€ì¥ ë†’ì€ ë•ŒëŠ”?", a: "ì˜¤í›„ 2~3ì‹œê²½", w: ["ì •ì˜¤ (12ì‹œ)", "í•´ ì§ˆ ë¬´ë µ"] },
    { q: "ì§€ë©´ì´ ë°ì›Œì ¸ ê³µê¸°ê°€ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” í˜„ìƒì€?", a: "ëŒ€ë¥˜ í˜„ìƒ", w: ["ë³µì‚¬ í˜„ìƒ", "ì „ë„ í˜„ìƒ"] },
    { q: "ë¹„ê°€ ë‚´ë¦¬ëŠ” ì–‘ì„ ì¸¡ì •í•˜ëŠ” ê¸°êµ¬ëŠ”?", a: "ìš°ëŸ‰ê³„", w: ["í’í–¥ê³„", "ìŠµë„ê³„"] },
    { q: "ê³µê¸°ì˜ ë¬´ê²Œë¡œ ì¸í•´ ìƒê¸°ëŠ” ì••ë ¥ì€?", a: "ê¸°ì••", w: ["ìˆ˜ì••", "í˜ˆì••"] },
    { q: "ê³µê¸°ì˜ ìŠµë„ë¥¼ ì¸¡ì •í•˜ëŠ” ë„êµ¬ëŠ”?", a: "ê±´ìŠµêµ¬ ì˜¨ë„ê³„", w: ["ì˜¨ë„ê³„", "ê¸°ì••ê³„"] },
    { q: "ê±´êµ¬ì™€ ìŠµêµ¬ ì˜¨ë„ì˜ ì°¨ì´ê°€ ì—†ì„ ë•Œ ìŠµë„ëŠ”?", a: "100%", w: ["0%", "50%"] },
    { q: "ìˆ˜ì¦ê¸°ê°€ ì°¨ê°€ìš´ ë¬¼ì²´ í‘œë©´ì— ë§ºí˜€ ë¬¼ë°©ìš¸ì´ ëœ ê²ƒì€?", a: "ì´ìŠ¬", w: ["ì•ˆê°œ", "êµ¬ë¦„"] },
    { q: "ê³µê¸° ì¤‘ ìˆ˜ì¦ê¸°ê°€ ì‘ê²°í•˜ì—¬ ì§€í‘œë©´ ê·¼ì²˜ì—ì„œ ë¿Œì˜‡ê²Œ ë³´ì´ëŠ” í˜„ìƒì€?", a: "ì•ˆê°œ", w: ["ì´ìŠ¬", "êµ¬ë¦„"] },
    { q: "ê³µê¸° ë©ì–´ë¦¬ê°€ í•˜ëŠ˜ ë†’ì´ ì˜¬ë¼ê°€ ë¬¼ë°©ìš¸ì´ë‚˜ ì–¼ìŒ ì•Œê°±ì´ê°€ ëœ ê²ƒì€?", a: "êµ¬ë¦„", w: ["ì´ìŠ¬", "ì•ˆê°œ"] },
    { q: "ì£¼ë³€ë³´ë‹¤ ê³µê¸°ì˜ ì••ë ¥ì´ ë†’ì€ ê³³ì€?", a: "ê³ ê¸°ì••", w: ["ì €ê¸°ì••", "ë¬´ê¸°ì••"] },
    { q: "ë‚®ì— ë°”ë‹¤ì—ì„œ ìœ¡ì§€ë¡œ ë¶€ëŠ” ë°”ëŒì€?", a: "í•´í’", w: ["ìœ¡í’", "ê³„ì ˆí’"] },
    { q: "ë°¤ì— ìœ¡ì§€ì—ì„œ ë°”ë‹¤ë¡œ ë¶€ëŠ” ë°”ëŒì€?", a: "ìœ¡í’", w: ["í•´í’", "ëŒí’"] },
    { q: "ìš°ë¦¬ë‚˜ë¼ ì—¬ë¦„ì²  ë‚ ì”¨ì— ì˜í–¥ì„ ì£¼ëŠ” ê¸°ë‹¨ì˜ ì„±ì§ˆì€?", a: "ë¥ê³  ìŠµí•˜ë‹¤", w: ["ì°¨ê³  ê±´ì¡°í•˜ë‹¤", "ë”°ëœ»í•˜ê³  ê±´ì¡°í•˜ë‹¤"] },
    { q: "ê²¨ìš¸ì²  ì°¨ê°‘ê³  ê±´ì¡°í•œ ë°”ëŒì„ ë³´ë‚´ëŠ” ê¸°ë‹¨ì€?", a: "ì‹œë² ë¦¬ì•„ ê¸°ë‹¨", w: ["ë¶íƒœí‰ì–‘ ê¸°ë‹¨", "ì˜¤í˜¸ì¸ í¬í•´ ê¸°ë‹¨"] },
    { q: "ê³ ê¸°ì•• ì§€ì—­ì˜ ë‚ ì”¨ëŠ” ëŒ€ì²´ë¡œ ì–´ë– í•œê°€ìš”?", a: "ë§‘ë‹¤", w: ["íë¦¬ë‹¤", "ë¹„ê°€ ì˜¨ë‹¤"] },
    { q: "í–‡ë¹›ì´ ì˜¤ë«ë™ì•ˆ ë‚´ë¦¬ì¬ì–´ì„œ ì˜¨ë„ê°€ ë†’ì€ ì•¼ì™¸ì™€ ì—ì–´ì»¨ì„ í‹€ì–´ë†“ì€ ì‹¤ë‚´ ì¤‘ ì–´ëŠ ê³³ì˜ ê¸°ì••ì´ ë” ë†’ì„ê¹Œ?", a: "ì‹¤ë‚´", w: ["ì•¼ì™¸", "ê¸°ì••ì´ ê°™ë‹¤"] },

    // [ì˜¨ë„ì™€ ì—´]
    { q: "ê³ ì²´ì—ì„œ ì—´ì´ ì˜¨ë„ê°€ ë†’ì€ ê³³ì—ì„œ ë‚®ì€ ê³³ìœ¼ë¡œ ì´ë™í•˜ëŠ” í˜„ìƒì€?", a: "ì „ë„", w: ["ëŒ€ë¥˜", "ë‹¨ì—´"] },
    { q: "ê¸ˆì† ë§‰ëŒ€ì˜ í•œìª½ ëì„ ê°€ì—´í•˜ë©´ ì—´ì€ ì–´ë–»ê²Œ ì´ë™í• ê¹Œìš”?", a: "ê°€ì—´í•œ ê³³ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™", w: ["ê°€ì—´í•œ ë¶€ë¶„ì—ë§Œ ë¨¸ë¬¸ë‹¤", "ì˜¨ë„ê°€ ë‚®ì€ ê³³ì—ì„œ ë†’ì€ ê³³ìœ¼ë¡œ ì´ë™"] },
    { q: "ì•¡ì²´ë‚˜ ê¸°ì²´ì—ì„œ ì˜¨ë„ê°€ ë†’ì•„ì§„ ë¬¼ì§ˆì´ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì—´ì˜ ì´ë™ ë°©ì‹ì€?", a: "ëŒ€ë¥˜", w: ["ì „ë„", "ë³µì‚¬"] },
    { q: "ì£¼ì „ì ì†ì˜ ë¬¼ì´ ì „ì²´ì ìœ¼ë¡œ ë”°ëœ»í•´ì§€ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ ë•Œë¬¸ì¼ê¹Œìš”?", a: "ëŒ€ë¥˜", w: ["ì „ë„", "ë‹¨ì—´"] },
    { q: "ì—´ì˜ ì´ë™ì„ ë§‰ì•„ ì˜¨ë„ë¥¼ ìœ ì§€í•˜ëŠ” ê²ƒì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", a: "ë‹¨ì—´", w: ["ì „ë„", "ëŒ€ë¥˜"] },
    { q: "ë³´ì˜¨ë³‘ì˜ ë²½ì„ ì´ì¤‘ìœ¼ë¡œ ë§Œë“¤ê³  ê·¸ ì‚¬ì´ë¥¼ ë¹„ìš°ëŠ” ëª©ì ì€?", a: "ì—´ì˜ ì´ë™ì„ ë§‰ê¸° ìœ„í•´", w: ["ë¬´ê²Œë¥¼ ê°€ë³ê²Œ í•˜ê¸° ìœ„í•´", "ëª¨ì–‘ì„ ì˜ˆì˜ê²Œ ë§Œë“¤ê¸° ìœ„í•´"] },
    { q: "ë‹¤ìŒ ì¤‘ ì „ë„ê°€ ê°€ì¥ ì˜ ì¼ì–´ë‚˜ëŠ” ë¬¼ì§ˆì€?", a: "êµ¬ë¦¬", w: ["ë‚˜ë¬´", "ìœ ë¦¬"] },

    // [íƒœì–‘ê³„ì™€ ë³„]
    { q: "ìŠ¤ìŠ¤ë¡œ ë¹›ì„ ë‚´ëŠ” íƒœì–‘ê³„ì˜ ìœ ì¼í•œ ë³„ì€?", a: "íƒœì–‘", w: ["ì§€êµ¬", "ë‹¬"] },
    { q: "íƒœì–‘ê³„ í–‰ì„± ì¤‘ íƒœì–‘ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í–‰ì„±ì€?", a: "ìˆ˜ì„±", w: ["ê¸ˆì„±", "ì§€êµ¬"] },
    { q: "íƒœì–‘ê³„ í–‰ì„± ì¤‘ í¬ê¸°ê°€ ê°€ì¥ í° í–‰ì„±ì€?", a: "ëª©ì„±", w: ["í† ì„±", "ì²œì™•ì„±"] },
    { q: "íƒœì–‘ì—ì„œ í–‰ì„±ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ë¹„êµí•  ë•Œ ê°€ì¥ ë©€ë¦¬ ìˆëŠ” í–‰ì„±ì€?", a: "í•´ì™•ì„±", w: ["í™”ì„±", "í† ì„±"] },
    { q: "ë¶ìª½ í•˜ëŠ˜ì—ì„œ ìœ„ì¹˜ê°€ ê±°ì˜ ë³€í•˜ì§€ ì•Šì•„ ë°©í–¥ì˜ ê¸°ì¤€ì´ ë˜ëŠ” ë³„ì€?", a: "ë¶ê·¹ì„±", w: ["ì‹œë¦¬ìš°ìŠ¤", "ê²¬ìš°ì„±"] },
    { q: "ë¶ê·¹ì„±ì„ ì°¾ê¸° ìœ„í•´ ì´ìš©í•˜ëŠ” êµ­ì ëª¨ì–‘ì˜ ë³„ìë¦¬ëŠ”?", a: "ë¶ë‘ì¹ ì„±", w: ["ì‚¬ììë¦¬", "ì˜¤ë¦¬ì˜¨ìë¦¬"] },
    { q: "ë³„ê³¼ í–‰ì„±ì˜ ì°¨ì´ì  ì¤‘ ë§ëŠ” ê²ƒì€?", a: "ë³„ì€ ìŠ¤ìŠ¤ë¡œ ë¹›ì„ ë‚´ì§€ë§Œ í–‰ì„±ì€ ê·¸ë ‡ì§€ ëª»í•˜ë‹¤", w: ["í–‰ì„±ì´ ìŠ¤ìŠ¤ë¡œ ë¹›ì„ ë‚¸ë‹¤", "ë‘˜ ë‹¤ ìŠ¤ìŠ¤ë¡œ ë¹›ì„ ë‚¸ë‹¤"] },
    { q: "ì¹´ì‹œì˜¤í˜ì´ì•„ìë¦¬ëŠ” ì–´ë–¤ ëª¨ì–‘ì¸ê°€ìš”?", a: "'W'ì ëª¨ì–‘", w: ["êµ­ì ëª¨ì–‘", "ì‚¬ì ëª¨ì–‘"] },
    { q: "ë°¤í•˜ëŠ˜ì—ì„œ ë©°ì¹  ë™ì•ˆ ê´€ì°°í–ˆì„ ë•Œ ìœ„ì¹˜ê°€ ë³€í•˜ëŠ” ì²œì²´ëŠ”?", a: "í–‰ì„±", w: ["ë³„", "ë³„ìë¦¬"] },

    // [ìš©í•´ì™€ ìš©ì•¡]
    { q: "ì„¤íƒ•ì´ ë¬¼ì— ë…¹ì•„ ì„ì´ëŠ” í˜„ìƒì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", a: "ìš©í•´", w: ["ìœµí•´", "ì‘ê³ "] },
    { q: "ì„¤íƒ•ë¬¼ì—ì„œ ì„¤íƒ•ì²˜ëŸ¼ ë…¹ëŠ” ë¬¼ì§ˆì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", a: "ìš©ì§ˆ", w: ["ìš©ë§¤", "ìš©ì•¡"] },
    { q: "ì„¤íƒ•ë¬¼ì—ì„œ ë¬¼ì²˜ëŸ¼ ë…¹ì´ëŠ” ë¬¼ì§ˆì„ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", a: "ìš©ë§¤", w: ["ìš©ì§ˆ", "ìš©ì•¡"] },
    { q: "ì„¤íƒ•ë¬¼ì„ ë‹¤ ë§Œë“¤ì—ˆì„ ë•Œ, ì„¤íƒ•ê³¼ ë¬¼ì´ ê³ ë¥´ê²Œ ì„ì¸ ìƒíƒœë¥¼ ë¬´ì—‡ì´ë¼ í•˜ë‚˜ìš”?", a: "ìš©ì•¡", w: ["ìš©ì§ˆ", "ìš©ë§¤"] },
    { q: "íˆ¬ëª…í•œ ë‘ ì„¤íƒ•ë¬¼ì˜ ì§„í•˜ê¸°ë¥¼ ë¹„êµí•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì˜³ì€ ê²ƒì€?", a: "ë§›ì„ ë³´ê±°ë‚˜ ë¬¼ì²´ë¥¼ ë„ì›Œ ë¹„êµí•œë‹¤", w: ["ë¹›ì„ ë¹„ì¶”ì–´ ë³¸ë‹¤", "ëƒ„ìƒˆë¥¼ ë§¡ì•„ ë¹„êµí•œë‹¤"] },
    { q: "ì¼ì •í•œ ì–‘ì˜ ë¬¼ì— ì†Œê¸ˆì„ ê³„ì† ë„£ìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?", a: "ì–´ëŠ ì •ë„ ë…¹ë‹¤ê°€ ë” ì´ìƒ ë…¹ì§€ ì•ŠëŠ”ë‹¤", w: ["ëì—†ì´ ë…¹ëŠ”ë‹¤", "ë¬¼ì´ ì‚¬ë¼ì§„ë‹¤"] },
    { q: "ì†Œê¸ˆì„ ë” ë§ì´ ë…¹ì´ë ¤ë©´ ë¬¼ì„ ì–´ë–»ê²Œ í•´ì•¼ í•˜ë‚˜ìš”?", a: "ë¬¼ì˜ ì˜¨ë„ë¥¼ ë†’ì¸ë‹¤", w: ["ë¬¼ì˜ ì–‘ì„ ì¤„ì¸ë‹¤", "ë¶€ì±„ë¡œ ë°”ëŒì„ ì¼ìœ¼í‚¨ë‹¤"] },
    { q: "2ê°€ì§€ ì„¤íƒ•ë¬¼ì— ë°©ìš¸í† ë§ˆí† ë¥¼ ë„£ì—ˆì„ ë•Œ ë°©ìš¸í† ë§ˆí† ê°€ ë” ë†’ì´ ë– ì˜¤ë¥¸ ì„¤íƒ•ë¬¼ì€?", a: "ë” ì§„í•˜ë‹¤", w: ["ë” ì—°í•˜ë‹¤", "ì•Œ ìˆ˜ ì—†ë‹¤"] },

    // [ë‹¤ì–‘í•œ ìƒë¬¼ê³¼ ìš°ë¦¬ ìƒí™œ]
    { q: "ëˆˆì— ë³´ì´ì§€ ì•ŠëŠ” ì‘ì€ ìƒë¬¼ì„ ê´€ì°°í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ë„êµ¬ëŠ”?", a: "ê´‘í•™ í˜„ë¯¸ê²½", w: ["ë§ì›ê²½", "ë‹ë³´ê¸°"] },
    { q: "ê³°íŒ¡ì´ë‚˜ ë²„ì„¯ì²˜ëŸ¼ í¬ìë¡œ ë²ˆì‹í•˜ëŠ” ìƒë¬¼ ë¬´ë¦¬ëŠ”?", a: "ê· ë¥˜", w: ["ì›ìƒ ìƒë¬¼", "ì‹ë¬¼"] },
    { q: "ë¬¼ì†ì— ì‚´ë©° ëª¸ì´ ì´ˆë¡ìƒ‰ ì„  ëª¨ì–‘ì¸ ì›ìƒ ìƒë¬¼ì€?", a: "í•´ìº„", w: ["ì§šì‹ ë²Œë ˆ", "ì„¸ê· "] },
    { q: "ì§šì‹  ëª¨ì–‘ì„ ë‹®ì•˜ìœ¼ë©° ìŠ¤ìŠ¤ë¡œ ì›€ì§ì´ëŠ” ì›ìƒ ìƒë¬¼ì€?", a: "ì§šì‹ ë²Œë ˆ", w: ["í•´ìº„", "ê³°íŒ¡ì´"] },
    { q: "ê· ë¥˜ê°€ ì˜ ìë¼ëŠ” í™˜ê²½ì€?", a: "ë”°ëœ»í•˜ê³  ìŠµê¸°ê°€ ë§ì€ ê³³", w: ["ê±´ì¡°í•œ ê³³", "í–‡ë¹›ì´ ê°•í•œ ê³³"] },
    { q: "ìš°ë¦¬ ì£¼ë³€ ì–´ë””ì—ë‚˜ ìˆìœ¼ë©° ì¡°ê±´ì— ë§ìœ¼ë©´ ìˆ˜ê°€ ë¹ ë¥´ê²Œ ëŠ˜ì–´ë‚˜ëŠ” êµ¬ì¡°ê°€ ë‹¨ìˆœí•œ ìƒë¬¼ì€?", a: "ì„¸ê· ", w: ["ê· ë¥˜", "ë™ë¬¼"] },
    { q: "ìœ ì‚°ê· ì²˜ëŸ¼ ìš°ë¦¬ ìƒí™œì— ë„ì›€ì„ ì£¼ëŠ” ì„¸ê· ì˜ ì—­í• ì€?", a: "ìŒì‹ ë°œíš¨", w: ["ì§ˆë³‘ ìœ ë°œ", "ìŒì‹ ë¶€íŒ¨"] },
    { q: "ê³°íŒ¡ì´ê°€ ìš°ë¦¬ì—ê²Œ ì£¼ëŠ” í•´ë¡œìš´ ì ì€?", a: "ìŒì‹ ë¶€íŒ¨", w: ["ì‚°ì†Œ ê³µê¸‰", "ì˜ì–‘ë¶„ ìƒì„±"] },
    { q: "ì›ìƒ ìƒë¬¼ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ ì˜³ì€ ê²ƒì€?", a: "ì£¼ë¡œ ë¬¼ê¸°ê°€ ìˆëŠ” ê³³ì— ì‚°ë‹¤", w: ["ì‹ë¬¼ê³¼ ë˜‘ê°™ë‹¤", "ëˆˆìœ¼ë¡œ ì‰½ê²Œ ë³´ì¸ë‹¤"] },
    { q: "ì›ìƒ ìƒë¬¼ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ ì˜³ì€ ê²ƒì€?", a: "ë™ë¬¼ë„ ì‹ë¬¼ë„ ê· ë¥˜ë„ ì•„ë‹ˆë‹¤", w: ["ë™ë¬¼ì´ë‹¤", "ê· ë¥˜ì´ë‹¤"] },

    // [ìƒë¬¼ê³¼ í™˜ê²½]
    { q: "ìƒíƒœê³„ì—ì„œ í–‡ë¹›ìœ¼ë¡œ ì–‘ë¶„ì„ ì§ì ‘ ë§Œë“œëŠ” ìƒë¬¼ì€?", a: "ìƒì‚°ì", w: ["ì†Œë¹„ì", "ë¶„í•´ì"] },
    { q: "ë‹¤ë¥¸ ìƒë¬¼ì„ ë¨¹ì´ë¡œ í•˜ì—¬ ì–‘ë¶„ì„ ì–»ëŠ” ìƒë¬¼ì€?", a: "ì†Œë¹„ì", w: ["ìƒì‚°ì", "ë¶„í•´ì"] },
    { q: "ì£½ì€ ìƒë¬¼ì„ ë¶„í•´í•˜ì—¬ ì–‘ë¶„ì„ ì–»ëŠ” ìƒë¬¼ì€?", a: "ë¶„í•´ì", w: ["ìƒì‚°ì", "ì†Œë¹„ì"] },
    { q: "ìƒë¬¼ ì£¼ë³€ì˜ í–‡ë¹›, ë¬¼, ì˜¨ë„ ë“±ì„ ë¬´ì—‡ì´ë¼ í•˜ë‚˜ìš”?", a: "ë¹„ìƒë¬¼ ìš”ì†Œ", w: ["ìƒë¬¼ ìš”ì†Œ", "ì‚¬íšŒì  ìš”ì†Œ"] },
    { q: "ë¨¹ê³  ë¨¹íˆëŠ” ê´€ê³„ê°€ ì‚¬ìŠ¬ì²˜ëŸ¼ ì—°ê²°ëœ ê²ƒì€?", a: "ë¨¹ì´ì‚¬ìŠ¬", w: ["ë¨¹ì´ê·¸ë¬¼", "ë¨¹ì´í”¼ë¼ë¯¸ë“œ"] },
    { q: "ì—¬ëŸ¬ ê°œì˜ ë¨¹ì´ì‚¬ìŠ¬ì´ ê·¸ë¬¼ì²˜ëŸ¼ ë³µì¡í•˜ê²Œ ì—°ê²°ëœ ê²ƒì€?", a: "ë¨¹ì´ê·¸ë¬¼", w: ["ë¨¹ì´ì‚¬ìŠ¬", "ìƒë¬¼ ë†ì¶•"] },
    { q: "ìƒíƒœê³„ ë‚´ì—ì„œ ìƒë¬¼ì˜ ì¢…ë¥˜ì™€ ìˆ˜ê°€ ì¼ì •í•˜ê²Œ ìœ ì§€ë˜ëŠ” ìƒíƒœëŠ”?", a: "ìƒíƒœê³„ í‰í˜•", w: ["ìƒíƒœê³„ íŒŒê´´", "ìƒë¬¼ ë‹¤ì–‘ì„±"] },
    { q: "ìƒë¬¼ì´ í™˜ê²½ì— ë§ê²Œ ëª¸ì˜ í˜•íƒœë‚˜ ìŠµì„±ì´ ë³€í•˜ëŠ” ê²ƒì€?", a: "ì ì‘", w: ["ì´ë™", "íƒ„ìƒ"] },
    { q: "ê³°íŒ¡ì´ë‚˜ ì„¸ê· ì€ ìƒíƒœê³„ì—ì„œ ì–´ë–¤ ì—­í• ì„ í•˜ë‚˜ìš”?", a: "ë¶„í•´ì", w: ["ìƒì‚°ì", "ì†Œë¹„ì"] },
    { q: "ë¹„ìƒë¬¼ ìš”ì†Œ(ì˜¨ë„)ê°€ ìƒë¬¼ì— ì˜í–¥ì„ ì£¼ëŠ” ì‚¬ë¡€ëŠ”?", a: "ì² ìƒˆì˜ ì´ë™", w: ["ì§€ë ì´ê°€ í™ì„ ì¼êµ¬ëŠ” ê²ƒ", "ìˆ²ì´ ê³µê¸°ë¥¼ ë§‘ê²Œ í•˜ëŠ” ê²ƒ"] },

    // [ë¬¼ì²´ì˜ ìš´ë™]
    { q: "ë‹¨ìœ„ ì‹œê°„ ë™ì•ˆ ì´ë™í•œ ê±°ë¦¬ë¥¼ ë¬´ì—‡ì´ë¼ê³  í•˜ë‚˜ìš”?", a: "ì†ë ¥", w: ["ì‹œê°„", "ê±°ë¦¬"] },
    { q: "ê°™ì€ ê±°ë¦¬ë¥¼ ì´ë™í•  ë•Œ, ê±¸ë¦° ì‹œê°„ì´ ì§§ì„ìˆ˜ë¡ ë¹ ë¥´ê¸°ëŠ”?", a: "ë” ë¹ ë¥´ë‹¤", w: ["ë” ëŠë¦¬ë‹¤", "ê°™ë‹¤"] },
    { q: "ê°™ì€ ì‹œê°„ ë™ì•ˆ ì´ë™í•  ë•Œ, ì´ë™ ê±°ë¦¬ê°€ ê¸¸ìˆ˜ë¡ ë¹ ë¥´ê¸°ëŠ”?", a: "ë” ë¹ ë¥´ë‹¤", w: ["ë” ëŠë¦¬ë‹¤", "ê°™ë‹¤"] },
    { q: "ì†ë ¥ì„ êµ¬í•˜ëŠ” ì˜¬ë°”ë¥¸ ë°©ë²•ì€?", a: "ê±°ë¦¬ Ã· ì‹œê°„", w: ["ì‹œê°„ Ã· ê±°ë¦¬", "ê±°ë¦¬ Ã— ì‹œê°„"] },
    { q: "1ì‹œê°„ ë™ì•ˆ 30km ì›€ì§ì´ëŠ” ë¬¼ì²´ì˜ ì†ë ¥ì€?", a: "30km/h", w: ["30km/s", "30km/m"] },
    { q: "1ì´ˆ ë™ì•ˆ 30km ì›€ì§ì´ëŠ” ë¬¼ì²´ì˜ ì†ë ¥ì€?", a: "30km/s", w: ["30km/h", "30km/m"] },
    { q: "1ë¶„ ë™ì•ˆ 30km ì›€ì§ì´ëŠ” ë¬¼ì²´ì˜ ì†ë ¥ì€?", a: "30km/m", w: ["30km/s", "30km/h"] },
    { q: "10ì´ˆ ë™ì•ˆ 100më¥¼ ë‹¬ë¦° ì‚¬ëŒì˜ ì†ë ¥ì€?", a: "10m/s", w: ["1m/s", "100m/s"] },
    { q: "ë¹ ë¥´ê¸°ê°€ ì¼ì •í•œ ìš´ë™ì˜ ì˜ˆëŠ”?", a: "ì—ìŠ¤ì»¬ë ˆì´í„°", w: ["ë–¨ì–´ì§€ëŠ” ê³µ", "ì¶œë°œí•˜ëŠ” ê¸°ì°¨"] },
    { q: "ë¹ ë¥´ê¸°ê°€ ë³€í•˜ëŠ” ìš´ë™ì˜ ì˜ˆëŠ”?", a: "ë‚ ì•„ê°€ëŠ” ì¶•êµ¬ê³µ", w: ["ëŒ€ê´€ëŒì°¨", "ì»¨ë² ì´ì–´ ë²¨íŠ¸"] },
    { q: "100m ë‹¬ë¦¬ê¸° ê¸°ë¡ì´ AëŠ” 15ì´ˆ, BëŠ” 20ì´ˆë¼ë©´ ëˆ„ê°€ ë” ë¹ ë¥¸ê°€ìš”?", a: "A", w: ["B", "ë˜‘ê°™ë‹¤"] },

    // [ì‚°ê³¼ ì—¼ê¸°]
    { q: "ìš©ì•¡ì˜ ì„±ì§ˆì— ë”°ë¼ ìƒ‰ê¹”ì´ ë³€í•˜ëŠ” ë¬¼ì§ˆì€?", a: "ì§€ì‹œì•½", w: ["ìš©ë§¤", "ìš©ì§ˆ"] },
    { q: "í‘¸ë¥¸ìƒ‰ ë¦¬íŠ¸ë¨¸ìŠ¤ ì¢…ì´ë¥¼ ë¶‰ê²Œ ë³€í™”ì‹œí‚¤ëŠ” ìš©ì•¡ì€?", a: "ì‚°ì„± ìš©ì•¡", w: ["ì—¼ê¸°ì„± ìš©ì•¡", "ì¤‘ì„± ìš©ì•¡"] },
    { q: "í˜ë†€í”„íƒˆë ˆì¸ ìš©ì•¡ì„ ë¶‰ê²Œ ë³€í™”ì‹œí‚¤ëŠ” ìš©ì•¡ì€?", a: "ì—¼ê¸°ì„± ìš©ì•¡", w: ["ì‚°ì„± ìš©ì•¡", "ì¤‘ì„± ìš©ì•¡"] },
    { q: "ë‹¤ìŒ ì¤‘ ëŒ€í‘œì ì¸ ì‚°ì„± ìš©ì•¡ì€?", a: "ì‹ì´ˆ", w: ["ë¹„ëˆ—ë¬¼", "ì„íšŒìˆ˜"] },
    { q: "ë‹¤ìŒ ì¤‘ ëŒ€í‘œì ì¸ ì—¼ê¸°ì„± ìš©ì•¡ì€?", a: "ë¹„ëˆ—ë¬¼", w: ["ë ˆëª¬ì¦™", "ì‚¬ì´ë‹¤"] },
    { q: "ì‚°ì„± ìš©ì•¡ì— ë‹¬ê±€ ê»ë°ê¸°ë¥¼ ë„£ìœ¼ë©´ ì–´ë–¤ ë³€í™”ê°€ ìƒê¸°ë‚˜ìš”?", a: "ê¸°í¬ê°€ ë°œìƒí•˜ë©° ë…¹ëŠ”ë‹¤", w: ["ë³€í™” ì—†ë‹¤", "ë”±ë”±í•´ì§„ë‹¤"] },
    { q: "ì—¼ê¸°ì„± ìš©ì•¡ì˜ ê³µí†µì ì¸ íŠ¹ì§•ì€?", a: "ë‘ë¶€ë‚˜ ê³„ë€ í°ì ê°™ì€ ë¬¼ì§ˆì„ ë…¹ì¸ë‹¤", w: ["ì‹ ë§›ì´ ë‚œë‹¤", "ê¸ˆì†ì„ ë…¹ì¸ë‹¤"] },
    { q: "ì‚°ì„± ìš©ì•¡ê³¼ ì—¼ê¸°ì„± ìš©ì•¡ì„ ì„ìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?", a: "ê° ìš©ì•¡ì˜ ì„±ì§ˆì´ ì•½í•´ì§„ë‹¤", w: ["ì„±ì§ˆì´ ë” ê°•í•´ì§„ë‹¤", "ì•„ë¬´ ë³€í™” ì—†ë‹¤"] },
    { q: "ìƒì„  ë¹„ë¦°ë‚´(ì—¼ê¸°ì„±)ì— ë ˆëª¬ì¦™ì„ ë¿Œë¦¬ëŠ” ì´ìœ ëŠ”?", a: "ì‚°ì„±ìœ¼ë¡œ ì¤‘í™”í•˜ë ¤ê³ ", w: ["ë” ë¹„ë¦¬ê²Œ í•˜ë ¤ê³ ", "ë§›ì„ ì—†ì• ë ¤ê³ "] },
    { q: "ìì£¼ìƒ‰ ì–‘ë°°ì¶” ì§€ì‹œì•½ì´ ë¶‰ì€ìƒ‰ìœ¼ë¡œ ë³€í–ˆë‹¤ë©´ ê·¸ ìš©ì•¡ì€?", a: "ì‚°ì„±", w: ["ì—¼ê¸°ì„±", "ì¤‘ì„±"] },
    { q: "ì†ì´ ì“°ë¦´ ë•Œ ë¨¹ëŠ” ì œì‚°ì œëŠ” ì–´ë–¤ ì„±ì§ˆì¼ê¹Œìš”?", a: "ì—¼ê¸°ì„±", w: ["ì‚°ì„±", "ì¤‘ì„±"] },
    { q: "ì‚°ì„± ìš©ì•¡ì— ëŒ€ë¦¬ì„ ì¡°ê°ì„ ë„£ìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?", a: "ëŒ€ë¦¬ì„ì´ ë…¹ëŠ”ë‹¤", w: ["ëŒ€ë¦¬ì„ì´ ì»¤ì§„ë‹¤", "ë³€í™” ì—†ë‹¤"] }
];

/**
 * 2. ê²Œì„ ìƒíƒœ ë³€ìˆ˜
 */
let gameState = 'START'; // START, PLAYING, PAUSED, GAMEOVER
let frameCount = 0;
let score = 0;
let gameSpeed = 1.5;

// í†µê³„ ë³€ìˆ˜
let nickname = "í•™ìƒ";
let totalCorrect = 0;
let consecutiveCorrect = 0;
let maxCombo = 0;

// ê°ì²´ ë°°ì—´
let bullets = [];
let enemies = [];
let gates = [];
let particles = [];
let floatingTexts = [];

// ë¬¸ì œ ë° ìŠ¤í° ì œì–´
let currentQuestionObj = null;
let nextGateFrame = 0;
let player;
let targetX;

/**
 * 3. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ (ì…”í”Œ, ì €ì¥ ë“±)
 */
// ë°°ì—´ ì„ê¸° (Fisher-Yates)
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í‚¤
const SAVE_KEY = 'weatherRun_save_v2';
const RECORD_KEY = 'weatherRun_records_v2';

// ê²Œì„ ì €ì¥
function saveGame() {
    if (gameState !== 'PLAYING' && gameState !== 'PAUSED') return;
    
    const saveData = {
        score, totalCorrect, consecutiveCorrect, maxCombo, nickname, frameCount, nextGateFrame,
        player: { x: player.x, y: player.y, soldiers: player.soldiers },
        enemies: enemies.map(e => ({x: e.x, y: e.y, hp: e.hp})),
        gates: gates.map(g => ({x: g.x, y: g.y, width: g.width, text: g.text, isCorrect: g.isCorrect, passed: g.passed})),
        currentQuestionObj
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
}

// ì €ì¥ëœ ê²Œì„ í™•ì¸
function checkSavedGame() {
    return localStorage.getItem(SAVE_KEY) !== null;
}

// ê²Œì„ ê¸°ë¡ ì €ì¥
function saveRecord() {
    let records = JSON.parse(localStorage.getItem(RECORD_KEY) || "[]");
    records.push({
        name: nickname,
        score: Math.floor(score),
        correct: totalCorrect,
        date: new Date().toLocaleDateString()
    });
    // ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    records.sort((a, b) => b.score - a.score);
    // ìƒìœ„ 10ê°œë§Œ ìœ ì§€
    records = records.slice(0, 10);
    localStorage.setItem(RECORD_KEY, JSON.stringify(records));
}

/**
 * 4. í´ë˜ìŠ¤ ì •ì˜
 */
class Player {
    constructor(x, y, soldiers) {
        this.width = 40;
        this.height = 40;
        this.x = x ?? (GAME_WIDTH / 2 - 20);
        this.y = y ?? (GAME_HEIGHT - 150);
        this.soldiers = soldiers ?? 10;
        this.color = '#3498db';
        this.lastShotTime = 0;
    }

    update() {
        if (this.soldiers <= 0) endGame();

        // ë°œì‚¬ ì†ë„
        const fireRate = Math.max(100, 500 - (this.soldiers * 2));
        const now = Date.now();
        if (now - this.lastShotTime > fireRate) {
            this.shoot();
            this.lastShotTime = now;
        }
    }

    draw() {
        const count = Math.floor(this.soldiers);
        const maxIndividualDraw = 30; 
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;

        let drawCount = count;
        let size = 60; 

        if (count <= maxIndividualDraw) {
            size = 70 / Math.sqrt(count);
            if(size > 60) size = 60;
            if(size < 20) size = 20;
        } else {
            drawCount = maxIndividualDraw;
            size = 20;
        }

        for(let i=0; i<drawCount; i++) {
             const angle = i * 2.4; 
             const dist = 7 * Math.sqrt(i);
             const rot = frameCount * 0.02;
             const dx = Math.cos(angle + rot) * dist;
             const dy = Math.sin(angle + rot) * dist;

             if (playerImg.complete && playerImg.naturalWidth > 0) {
                 ctx.drawImage(playerImg, cx + dx - size/2, cy + dy - size/2, size, size);
             } else {
                 ctx.fillStyle = this.color;
                 ctx.beginPath();
                 ctx.arc(cx + dx, cy + dy, size/2, 0, Math.PI*2);
                 ctx.fill();
             }
        }

        if (count > maxIndividualDraw) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.strokeText(count, cx, cy - 50);
            ctx.fillText(count, cx, cy - 50);
        }
    }

    shoot() {
        // ê¸°ë³¸: ë³‘ì‚¬ ìˆ˜ì— ë”°ë¼ ë°œì‚¬ì²´ ê°œìˆ˜ ì¦ê°€
        let count = 1;
        if (this.soldiers >= 10) count = 2;
        if (this.soldiers >= 30) count = 3; // ì—¬ê¸°ì„œë¶€í„° ëŒ€ê°ì„ 
        if (this.soldiers >= 60) count = 5;
        if (this.soldiers >= 100) count = 7;

        // ëŒ€ê°ì„  ë°œì‚¬ ì—¬ë¶€ (30ëª… ì´ìƒ)
        const useSpread = this.soldiers >= 30;
        
        for(let i=0; i<count; i++) {
            let angle = 0;
            let startX = this.x + this.width/2;

            if (useSpread) {
                // ë¶€ì±„ê¼´ ë°œì‚¬
                const maxSpread = 0.5; // ìµœëŒ€ ë²Œì–´ì§€ëŠ” ê°ë„ (ë¼ë””ì•ˆ, ì•½ 30ë„)
                if (count > 1) {
                    angle = -maxSpread/2 + (maxSpread / (count-1)) * i;
                }
            } else {
                // ê¸°ì¡´ í‰í–‰ ë°œì‚¬ (ì¢ê²Œ)
                const spreadX = 10;
                const offset = (i - (count-1)/2) * spreadX;
                startX += offset;
            }
            
            bullets.push(new Bullet(startX, this.y, angle));
        }
    }
}

class Bullet {
    constructor(x, y, angle = 0) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.radius = 4;
        this.speed = 10;
        this.markedForDeletion = false;
    }
    update() {
        // angleì´ 0ì´ë©´ ìœ„ë¡œ(y ê°ì†Œ), ì–‘ìˆ˜ë©´ ì˜¤ë¥¸ìª½ ê¸°ìš¸ê¸°, ìŒìˆ˜ë©´ ì™¼ìª½ ê¸°ìš¸ê¸°
        this.x += Math.sin(this.angle) * this.speed;
        this.y -= Math.cos(this.angle) * this.speed;
        
        if (this.y < 0 || this.x < 0 || this.x > GAME_WIDTH) this.markedForDeletion = true;
    }
    draw() {
        ctx.fillStyle = '#f1c40f';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Enemy {
    constructor(x, y, hp, packSize = 1) {
        this.width = 40;
        this.height = 40;
        this.x = x ?? Math.random() * (GAME_WIDTH - 40);
        this.y = y ?? -50;
        this.speed = gameSpeed + Math.random() * 2;
        
        // ë­‰ì¹œ í¬ê¸° (ê¸°ë³¸ 1)
        this.packSize = packSize;
        
        // ì²´ë ¥: ë­‰ì¹œ ê°œìˆ˜ * 3 (ê¸°ë³¸ ì²´ë ¥ 3)
        this.hp = hp ?? (3 * this.packSize);
        
        this.markedForDeletion = false;
        this.color = '#e74c3c';
    }
    update() {
        this.y += this.speed;
        if (this.y > GAME_HEIGHT) this.markedForDeletion = true;
    }
    draw() {
        // ê²Œì´íŠ¸ì™€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸ (ë°˜íˆ¬ëª… ì²˜ë¦¬)
        let isOverlapping = false;
        for(const gate of gates) {
            if (this.x < gate.x + gate.width &&
                this.x + this.width > gate.x &&
                this.y < gate.y + gate.height &&
                this.y + this.height > gate.y) {
                isOverlapping = true;
                break;
            }
        }

        if (isOverlapping) ctx.globalAlpha = 0.3;

        // ë­‰ì¹œ ì  ê·¸ë¦¬ê¸°
        if (this.packSize > 1) {
            // ì—¬ëŸ¬ ë§ˆë¦¬ ê²¹ì³ì„œ ê·¸ë¦¬ê¸° (ì•½ê°„ì”© ì˜¤í”„ì…‹)
            for(let i=0; i<this.packSize; i++) {
                const offsetX = (i % 2 === 0 ? 1 : -1) * (i * 5);
                const offsetY = (i * 5);
                
                if (enemyImg.complete && enemyImg.naturalWidth > 0) {
                    ctx.drawImage(enemyImg, this.x + offsetX, this.y - offsetY, this.width, this.height);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + offsetX, this.y - offsetY, this.width, this.height);
                }
            }
            
            // ë¨¸ë¦¬ ìœ„ì— ë‚¨ì€ ê°œìˆ˜(ì²´ë ¥ ê¸°ë°˜ ëŒ€ëµì  ìˆ˜ì¹˜) í‘œì‹œ
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            // í˜„ì¬ ë‚¨ì€ ë§ˆë¦¬ ìˆ˜ = ì˜¬ë¦¼(í˜„ì¬ ì²´ë ¥ / 3)
            const currentPackCount = Math.ceil(this.hp / 3);
            ctx.fillText(`x${currentPackCount}`, this.x + this.width/2, this.y - 10);

        } else {
            // ë‹¨ì¼ ì 
            if (enemyImg.complete && enemyImg.naturalWidth > 0) {
                ctx.drawImage(enemyImg, this.x, this.y, this.width, this.height);
            } else {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        if (isOverlapping) ctx.globalAlpha = 1.0;
    }
}

class Gate {
    constructor(x, width, text, isCorrect, passed, y) {
        this.x = x;
        this.y = y ?? -150;
        this.width = width;
        this.height = 100;
        this.text = text;
        this.isCorrect = isCorrect;
        this.passed = passed ?? false;
        this.markedForDeletion = false;
    }
    update() {
        this.y += gameSpeed;
        if (this.y > GAME_HEIGHT) this.markedForDeletion = true;
    }
    draw() {
        ctx.fillStyle = 'rgba(52, 152, 219, 0.6)'; 
        ctx.fillRect(this.x + 5, this.y, this.width - 10, this.height);
        ctx.strokeStyle = '#2980b9';
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x + 5, this.y, this.width - 10, this.height);

        // íŒíŠ¸ ìˆ¨ê¹€ (?)
        ctx.fillStyle = 'white';
        ctx.font = 'bold 30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText("?", this.x + this.width/2, this.y + 40);

        // ë³´ê¸° í…ìŠ¤íŠ¸
        ctx.font = '16px Malgun Gothic';
        wrapText(ctx, this.text, this.x + this.width/2, this.y + 70, this.width - 20, 20);
    }
}

// í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ (ìˆ˜ì •: ìƒë‹¨ ë¬¸ì œ í‘œì‹œì¤„ì—ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì¡°ì •)
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    
    // ë§Œì•½ ë‹¨ì–´ í•˜ë‚˜ê°€ ë„ˆë¬´ ê¸¸ë©´(ì˜ì–´ ë“±) ì˜ë¦¬ëŠ” ë¬¸ì œ ë°©ì§€
    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ê³µë°± ê¸°ì¤€ ë¶„ë¦¬ë§Œ ì²˜ë¦¬
    
    for(let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line, x, y);
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.life = 100;
    }
    update() { this.x += this.speedX; this.y += this.speedY; this.life -= 2; }
    draw() {
        ctx.globalAlpha = this.life / 100;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

function createFloatingText(text, x, y, color) {
    floatingTexts.push({text, x, y, color, life: 60});
}

/**
 * 5. ê²Œì„ ë¡œì§
 */
function spawnGateRow() {
    const qIndex = Math.floor(Math.random() * QUESTIONS.length);
    const qData = QUESTIONS[qIndex];
    currentQuestionObj = qData;

    const gateWidth = GAME_WIDTH / 3;
    
    // ë³´ê¸° ìƒì„± ë° ì…”í”Œ (ì •ë‹µ 1ê°œ + ì˜¤ë‹µ 2ê°œ)
    let options = [];
    options.push({ text: qData.a, isCorrect: true });
    
    // ì˜¤ë‹µ ë¦¬ìŠ¤íŠ¸ ì…”í”Œ í›„ 2ê°œ ì„ íƒ
    let wrongPool = shuffle([...qData.w]);
    options.push({ text: wrongPool[0] || "ì˜¤ë‹µ", isCorrect: false });
    options.push({ text: wrongPool[1] || wrongPool[0] || "ì˜¤ë‹µ", isCorrect: false }); // ì˜¤ë‹µ ë¶€ì¡±ì‹œ ì¤‘ë³µ ì²˜ë¦¬

    // ìµœì¢… ë°°ì¹˜ ì…”í”Œ
    options = shuffle(options);

    for(let i=0; i<3; i++) {
        gates.push(new Gate(i * gateWidth, gateWidth, options[i].text, options[i].isCorrect));
    }
}

function spawnEnemy() {
    // ê¸°ë³¸ ìƒì„± í™•ë¥  (ì‹œê°„ ì§€ë‚ ìˆ˜ë¡ ì¦ê°€)
    if (Math.random() < 0.02 + (frameCount * 0.00001)) {
        // ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡(ì ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡) ë­‰ì³ì„œ ë‚˜ì˜¬ í™•ë¥  ì¦ê°€
        // ì˜ˆ: 1000í”„ë ˆì„ ì´í›„ë¶€í„° ë­‰ì¹œ ì  ë“±ì¥ ê°€ëŠ¥
        let packSize = 1;
        if (frameCount > 1000 && Math.random() < 0.3) {
            // 2~5ë§ˆë¦¬ ë­‰ì¹¨
            packSize = Math.floor(Math.random() * 4) + 2; 
        }
        
        enemies.push(new Enemy(null, null, null, packSize));
    }
}

function checkCollisions() {
    // ì´ì•Œ vs ì 
    bullets.forEach(bullet => {
        enemies.forEach(enemy => {
            const dist = Math.hypot(bullet.x - (enemy.x + 20), bullet.y - (enemy.y + 20));
            if (dist < 20 + bullet.radius) {
                enemy.hp--;
                bullet.markedForDeletion = true;
                for(let i=0; i<3; i++) particles.push(new Particle(bullet.x, bullet.y, '#f1c40f'));
                if (enemy.hp <= 0) {
                    enemy.markedForDeletion = true;
                    score += 10;
                    for(let i=0; i<10; i++) particles.push(new Particle(enemy.x+20, enemy.y+20, '#e74c3c'));
                }
            }
        });
    });

    // í”Œë ˆì´ì–´ vs ì 
    enemies.forEach(enemy => {
        if (!enemy.markedForDeletion && 
            player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
            
            // ì¶©ëŒ ì‹œ ë³‘ì‚¬ ê°ì†Œ (ì ì˜ ë‚¨ì€ ë­‰ì¹œ ìˆ˜ë§Œí¼ ë¹„ë¡€í•´ì„œ ê°ì†Œ)
            // ì  1ë§ˆë¦¬ë‹¹ 5ëª… ê°ì†Œ * ë‚¨ì€ íŒ© í¬ê¸°
            const currentPackCount = Math.ceil(enemy.hp / 3);
            const damage = 5 * currentPackCount;
            
            player.soldiers -= damage;
            enemy.markedForDeletion = true;
            createFloatingText(`-${damage}`, player.x, player.y, "red");
            updateHUD();
            ctx.translate(5, 0); setTimeout(() => ctx.translate(-5, 0), 50);
        }
    });

    // í”Œë ˆì´ì–´ vs ê²Œì´íŠ¸
    gates.forEach(gate => {
        if (!gate.passed &&
            player.x < gate.x + gate.width && player.x + player.width > gate.x &&
            player.y < gate.y + gate.height && player.y + player.height > gate.y) {
            
            gate.passed = true;
            
            if (gate.isCorrect) {
                player.soldiers *= 2;
                totalCorrect++;
                consecutiveCorrect++;
                if(consecutiveCorrect > maxCombo) maxCombo = consecutiveCorrect;

                createFloatingText("ì •ë‹µ!", player.x, player.y - 50, "#2ecc71");
                score += 100;
                
                // ì½¤ë³´ íš¨ê³¼
                const comboElem = document.getElementById('hud-combo');
                comboElem.classList.remove('combo-active');
                void comboElem.offsetWidth; // trigger reflow
                comboElem.classList.add('combo-active');

            } else {
                player.soldiers = Math.floor(player.soldiers / 2);
                consecutiveCorrect = 0;
                createFloatingText("í‹€ë ¸ì–´!", player.x, player.y - 50, "#e74c3c");
            }

            gates.forEach(g => { if (Math.abs(g.y - gate.y) < 10) g.passed = true; });
            currentQuestionObj = null;
            updateHUD();
        }
    });
}

function updateHUD() {
    document.getElementById('hud-score').innerText = Math.floor(score);
    document.getElementById('hud-total').innerText = totalCorrect;
    document.getElementById('hud-combo').innerText = `Combo: ${consecutiveCorrect}`;
}

function drawRoad() {
    ctx.fillStyle = '#34495e';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 4;
    ctx.setLineDash([20, 20]);
    const lineOffset = (frameCount * gameSpeed) % 40;
    ctx.beginPath(); ctx.moveTo(GAME_WIDTH/3, -40+lineOffset); ctx.lineTo(GAME_WIDTH/3, GAME_HEIGHT); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(GAME_WIDTH*2/3, -40+lineOffset); ctx.lineTo(GAME_WIDTH*2/3, GAME_HEIGHT); ctx.stroke();
    ctx.setLineDash([]);
}

function drawUI() {
    // ìƒë‹¨ ë¬¸ì œ í‘œì‹œì¤„
    const uiHeight = 80;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, GAME_WIDTH, uiHeight);
    
    ctx.fillStyle = 'white'; 
    ctx.textAlign = 'center';
    
    if (currentQuestionObj) {
        ctx.font = 'bold 18px Malgun Gothic'; 
        ctx.fillStyle = '#f39c12';
        
        // ë¬¸ì œ í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ì²˜ë¦¬ (yì¢Œí‘œ 30ë¶€í„° ì‹œì‘, ì¤„ê°„ê²© 24)
        wrapText(ctx, "Q. " + currentQuestionObj.q, GAME_WIDTH/2, 30, GAME_WIDTH - 40, 24);
        
        // íŒíŠ¸ ë©”ì‹œì§€ (ë¬¸ì œ í…ìŠ¤íŠ¸ê°€ ê¸¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•˜ë‹¨ì— ê³ ì •í•˜ì§€ ì•Šê³  ìƒí™©ì— ë”°ë¼ ìœ„ì¹˜ ì¡°ì • ê°€ëŠ¥í•˜ë‚˜, ì¼ë‹¨ ê³ ì •)
        // ë§Œì•½ ë¬¸ì œê°€ ë„ˆë¬´ ê¸¸ë©´ ê²¹ì¹  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ í•˜ë‹¨ì— ë¶™ì—¬ì„œ ì¶œë ¥
        // ctx.font = '14px Malgun Gothic'; 
        // ctx.fillStyle = '#bdc3c7';
        // ctx.fillText("ì•Œë§ì€ ë³´ê¸°ë¥¼ ì°¾ì•„ ì´ë™í•˜ì„¸ìš”!", GAME_WIDTH/2, 70); 
    } else {
        ctx.font = 'bold 20px Malgun Gothic';
        ctx.fillText("ë‹¤ìŒ ë¬¸ì œ ì¤€ë¹„ ì¤‘...", GAME_WIDTH/2, 50);
    }
}

function animate() {
    if (gameState !== 'PLAYING') return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawRoad();

    player.x += (targetX - player.x) * 0.1;
    if (player.x < 0) player.x = 0;
    if (player.x > GAME_WIDTH - player.width) player.x = GAME_WIDTH - player.width;

    if (frameCount > nextGateFrame && !gates.some(g => g.y < GAME_HEIGHT && g.y > 0)) {
        spawnGateRow();
        nextGateFrame = frameCount + 400;
    }
    spawnEnemy();

    gates.forEach(g => { g.update(); g.draw(); });
    gates = gates.filter(g => !g.markedForDeletion);

    enemies.forEach(e => { e.update(); e.draw(); });
    enemies = enemies.filter(e => !e.markedForDeletion);

    player.update();
    player.draw();

    bullets.forEach(b => { b.update(); b.draw(); });
    bullets = bullets.filter(b => !b.markedForDeletion);

    particles.forEach(p => { p.update(); p.draw(); });
    particles = particles.filter(p => p.life > 0);

    floatingTexts.forEach((ft, idx) => {
        ft.y -= 1; ft.life--;
        ctx.globalAlpha = ft.life/60; ctx.fillStyle = ft.color;
        ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1.0;
        if(ft.life <= 0) floatingTexts.splice(idx, 1);
    });

    checkCollisions();
    drawUI();
    
    // ì ìˆ˜ ì¦ê°€ (ìƒì¡´ ì ìˆ˜)
    score += 0.1;
    if(frameCount % 10 === 0) updateHUD(); // HUD ì—…ë°ì´íŠ¸

    // [ì¶”ê°€] ì†ë„ ì ì§„ì  ì¦ê°€ (ìµœëŒ€ 2.0ê¹Œì§€)
    if (gameSpeed < 2.0) {
        gameSpeed += 0.0002; 
    }

    frameCount++;
    requestAnimationFrame(animate);
}

/**
 * 6. ì œì–´ ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
 */
// ë§ˆìš°ìŠ¤/í„°ì¹˜ ì…ë ¥
function handleInput(e) {
    if (gameState !== 'PLAYING') return;
    let clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    targetX = (clientX - rect.left) * scaleX - 20;
}
window.addEventListener('mousemove', handleInput);
window.addEventListener('touchmove', handleInput, {passive: false});
window.addEventListener('keydown', (e) => {
    if (gameState !== 'PLAYING') return;
    if (e.key === 'ArrowLeft') targetX -= 30;
    if (e.key === 'ArrowRight') targetX += 30;
});

// ì‹œì‘/ì¢…ë£Œ í•¨ìˆ˜
function startNewGame() {
    const nick = document.getElementById('nickname-input').value.trim();
    if(!nick) { alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
    nickname = nick;
    
    // ì´ì „ ì €ì¥ ì‚­ì œ (ìƒˆ ê²Œì„ì´ë¯€ë¡œ)
    localStorage.removeItem(SAVE_KEY);
    
    resetGameData();
    startGameCommon();
}

function loadGameAndStart() {
    const saveDataStr = localStorage.getItem(SAVE_KEY);
    if (!saveDataStr) return;

    const data = JSON.parse(saveDataStr);
    
    // ë°ì´í„° ë³µêµ¬
    score = data.score;
    totalCorrect = data.totalCorrect;
    consecutiveCorrect = data.consecutiveCorrect;
    maxCombo = data.maxCombo;
    nickname = data.nickname;
    frameCount = data.frameCount;
    nextGateFrame = data.nextGateFrame;
    currentQuestionObj = data.currentQuestionObj;

    player = new Player(data.player.x, data.player.y, data.player.soldiers);
    enemies = data.enemies.map(e => new Enemy(e.x, e.y, e.hp));
    gates = data.gates.map(g => new Gate(g.x, g.width, g.text, g.isCorrect, g.passed, g.y));
    
    targetX = player.x;
    
    startGameCommon();
}

function startGameCommon() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    gameState = 'PLAYING';
    animate();
}

function resetGameData() {
    player = new Player();
    bullets = []; enemies = []; gates = []; particles = []; floatingTexts = [];
    score = 0; frameCount = 0; nextGateFrame = 100;
    targetX = GAME_WIDTH / 2 - 20;
    totalCorrect = 0; consecutiveCorrect = 0; maxCombo = 0;
    currentQuestionObj = null;
    updateHUD();
}

function endGame() {
    gameState = 'GAMEOVER';
    saveRecord();
    localStorage.removeItem(SAVE_KEY); // ê²Œì„ ëë‚¬ìœ¼ë¯€ë¡œ ì €ì¥ ì‚­ì œ

    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('final-msg').innerText = `${nickname}ë‹˜ ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!`;
    document.getElementById('final-score-text').innerText = `ìµœì¢… ì ìˆ˜: ${Math.floor(score)}`;
    document.getElementById('final-stats-text').innerText = `ì •ë‹µ: ${totalCorrect}ê°œ / ìµœëŒ€ ì½¤ë³´: ${maxCombo}`;
}

function returnToMain() {
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    initStartScreen();
}

// ê¸°ë¡ ë³´ê¸°
function showRecords() {
    const records = JSON.parse(localStorage.getItem(RECORD_KEY) || "[]");
    const tbody = document.querySelector('#records-table tbody');
    tbody.innerHTML = '';
    
    if(records.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4">ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
    } else {
        records.forEach((rec, idx) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${idx+1}</td><td>${rec.name}</td><td>${rec.score}</td><td>${rec.correct}</td>`;
            tbody.appendChild(tr);
        });
    }
    document.getElementById('records-screen').classList.remove('hidden');
}
function hideRecords() {
    document.getElementById('records-screen').classList.add('hidden');
}

// ì´ˆê¸°í™” í™•ì¸
function initStartScreen() {
    if(checkSavedGame()) {
        document.getElementById('resume-area').classList.remove('hidden');
    } else {
        document.getElementById('resume-area').classList.add('hidden');
    }
}

// ìë™ ì €ì¥ (ì°½ ë‹«ê¸°/ìˆ¨ê¹€ ì‹œ)
document.addEventListener("visibilitychange", () => {
    if (document.hidden && gameState === 'PLAYING') {
        saveGame();
        gameState = 'PAUSED';
    } else if (!document.hidden && gameState === 'PAUSED') {
        // ë³µê·€ ì‹œ ìë™ ì‹¤í–‰ (ì„ íƒì‚¬í•­)
        gameState = 'PLAYING';
        animate();
    }
});

// ì°½ ë‹«ê¸° ì „ ì €ì¥
window.addEventListener('beforeunload', () => {
    if (gameState === 'PLAYING') saveGame();
});

window.addEventListener('resize', () => {
    GAME_WIDTH = window.innerWidth > 600 ? 600 : window.innerWidth;
    GAME_HEIGHT = window.innerHeight;
    canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;
    if(player) player.y = GAME_HEIGHT - 150;
});

// ì´ˆê¸° ì‹¤í–‰
initStartScreen();

</script>
</body>
</html>